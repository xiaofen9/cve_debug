# put_user arbitrary write Root for android

## intro
CVE-2013-6282 denotes the vulnerability that the (1) get_user and (2) put_user API functions in the Linux kernel before 3.5.5 on the v6k and v7 ARM platforms do not validate certain addresses, so we can do arbitrary write into arm kernel.

## Insight into code
Let's see the definition of put_user api
**arch/arm/include/asm/uaccess.h**
`
 __put_user_x(__r2,__p,__e,__s)					\
 	   __asm__ __volatile__ (					\
 		__asmeq("%0", "r0") __asmeq("%2", "r2")			\
 		"bl	__put_user_" #__s				\
 		: "=&r" (__e)						\
		: "0" (__p), "r" (__r2)					\
 		: "ip", "lr", "cc")
`

Let's see the definition of parameters:
`register const typeof(*(p)) __r2 asm("r2") = (x);	\
 register const typeof(*(p)) __user *__p asm("r0") = (p);\`. 

__r2 and __p respectively come from  r2 and r0. 

A vul must exhibit some parameters that can be input by malicious  users while these parameters will write or read into kernel.
### Kernel mode
First, let's trace the two and see how they are called in kernel. 
**arch/arm/lib/putuser.S**
`
 ENTRY(__put_user_1)
 1: TUSER(strb)	r2, [r0]
 	mov	r0, #0
 	mov	pc, lr
 ENDPROC(__put_user_1)
`  
The api directly store the bytes in r2 into the memory that pointed by r0, without any check! 

**Brainstorm**: if we are able to manipulate the two parameters...

### User mode 
Then, let's see the put_user in the user mode. There are various apis are using it, let we select one from them.
**fs/ioctl.c**
`
static int file_ioctl(struct file *filp, unsigned int cmd,
		unsigned long arg)
{
	struct inode *inode = filp->f_path.dentry->d_inode;
	int __user *p = (int __user *)arg;	switch (cmd) {
	case FIBMAP:
		return ioctl_fibmap(filp, p);
	case FIONREAD:
		return put_user(i_size_read(inode) - filp->f_pos, p);
	case FS_IOC_RESVSP:
	case FS_IOC_RESVSP64:
		return ioctl_preallocate(filp, p);
	}
	return vfs_ioctl(filp, cmd, arg);
}
`

We can see that `put_user(i_size_read(inode) - filp->f_pos, p);`, it calculates a offset and pass the offset with an address (arg) designated by users into kernel!

**Brainstorm**: If we can construct an arbitrary offset, we can write any thing into the kernel...


## Exploit
In this step, we need to figure out how to exploit the vulnerability to get root.

Typically, the exploitation is progressed as follows:

1. Modify the fsync pointer in the ptmx_fops table, and let it point to our shellcode in the user mode.
2. Call the fsync in the user mode, so that kernel will execute our shellcode in kernel mode.
3. Get rooted

Assume that the address of our shellcode is 0XAABB, and we need to replace the pointer of fsync with it.
Figuring out the address of fsync pointer in ptmx_table is easy, since the android kernel is static. Though we can not modify it under user mode.

**Attention** It is worth nothing that the result of &shellcode() will be the lower two bytes of address.  Generally, among most tables of the kernel, only the lower 2 bytes of an address will be stored for the purpose of saving space, and either does ptmx_fops table.


But How can we leverage ioctl along with flag `FIONREAD` to write 0xAABB to the known fsync pointer?

With the flag "FIONREAD", we can get to know how many bytes there are readable at a pipe. Inspired by this function, we can firstly write 0xBB byte into the pipe and write 0xBB to the address of fsync pointer.

`
for(i=0;i<2;i++)
{
     if(data[i])
        write(fd[1], buf, data[i]);
       	ioctl(fd[0], FIONREAD, (void *)(address+i));
       	if(data[i])
       	read(fd[0], buf, sizeof(buf));
    }    
`

**Attention**: During each time ioctl will write an int (4 btyes) to the address. So writing 2 bytes to the target address definitely leads to the situation that there is a miss overwrite on other items in the table. To illustrate:
Assume we want to write 0xAABB to address 0x1234, while *0x1234 is 0xEFGH.

**Loop 1**. writing 0x00BB (int) to [0x1234], thus *0x1234 will be 0x00BB (higher part is overwrite too)

**Loop 2**. writing 0x00AA (int) to [0x1234+1], thus *0x1234 will be 0xAABB while *0x1235 will be 0x00AA.

The total modification around address 0x1234 is 0x00AABB.

But never mind, destroying other items in the table will exert no negative influence on our following steps to get root, since we successfully hijack the fsync.

## Appendix 
Related code has been upload to [github](https://github.com/xiaofen9/cve_study/blob/master/CVE-2013-6282/put_user.c)   for your further study.

To compile it:
`ndk-build APP_BUILD_SCRIPT=./Android.mk APP_ABI=armeabi NDK_PROJECT_PATH=.`

 

